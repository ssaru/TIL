# Effective Go

업무상 golang을 사용해야해서, 기본적인 Golang 스터디를 진행한다.

​    

## 세미콜론; Semicolons

- Go의 정식문법은 구문을 종료하기 위하여 세미콜론`;`을 사용한다. 하지만 소스코드상에 나타나진 않는다.

  - 구문 분석기(lexer)가 간단한 `규칙`을 사용해서 스캔하고 그 과정에서 자동으로 세미콜론을 삽입한다.

  - 여기서 `규칙`이라고 하면, 새로운 라인 앞의 마지막 토큰이 `식별자`/`숫자`/`문자열`과 같은 기본 리터럴 혹은 아래와 같은 토큰들 중 하나라면, 구문 분석기(lexer)는 항상 토큰 다음에 세미콜론을 추가한다.

    ```go
    break
    continue
    fallthrough
    return
    ++
    --
    )
    }
    ```

    > 이는 `구문을 끝낼 수 있는 토큰 뒤에 새로운 라인이 오면, 세미콜론을 삽입하라`라는 말과 같다.

  - 세미콜론은 닫는 중괄호`}` 바로 앞에서 생략할 수 있다. 예를 들어 아래의 구문은 세미콜론이 필요하지 않다.

    ```go
    go fun() {for {dst <- <- src} }()
    ```

  - Go에서는 세미콜론을 for loop 구문에서 `변수 초기화`, `조건`, `진행 변수`를 구분할 때만 사용한다.

  - 세미콜론은 한 라인에서 여러 문장을 구분하기 위해 필요하다.

  - 세미콜론 입력규칙의 중요한 한가지는 아래와 같이 제어문(`if`, `for`, `swich`, `select`)의 여는 중괄호`{`를 다음 라인에 사용하지 말아야한다는 것이다.

    ```go
    if i < f() // wrong!
    {        // wrong!
        g()
    }
    ```

    > 이렇게 사용하게 되면 세미콜론은 중괄호`{` 앞에 추가될 것이고, 예상치 못한 영향을 발생시킬 것이다.

    따라서 제어문을 작성할 때는 다음과 같이 작성해라

    ```go
    if i < f(){
        g()
    }
    ```


    ## 제어구조

Go는 C의 제어구조를 많이 따라가지만 몇가지 중요한 차이점이 있다.

- `do`, `while` 반복문이 존재하지 않는다.
- `for`, `switch`가 존재한다.
- `if`, `switch`는 선택적으로 `for`와 같이 초기화 구문을 받을 수 있다.
- `break`와 `continue`구문들은 선택적으로 어느 것을 멈추거나 계속할지 식별하기 위해서 라벨을 받을 수 있다.
- `type switch`와 `multiway communications multiplexer`, `select`의 새로운 제어 구조가 포함되어 있다.
- 괄호는 필요 하지 않으며, body는 항상 중괄호로 구분해야한다.

​    

### If

Go의 if문에 대한 간단한 예제

```go
if x > 0{
    return y
}
```



중괄호를 의무적으로 사용해야 하기 때문에, 다중 라인에서 if 구문들이 간단하게 작성된다. 그렇게 하는 것이 좋은 스타일이며, 특히 구문 몸체에 return이나 break와 같은 제어 구문을 포함하고 있는 경우에는 더욱더 그러하다.

> Why??



`if`와 `switch`가 초기화 구문을 허용하므로 지역변수를 설정하기 위해 사용된 초기화 구문을 흔히 볼 수 있다.

```go
if err := file.Chmod(0664); err != nil{
    log.Print(err)
    return err
}
```



Go 여러 라이브러리를 보게되면, if 구문이 다음 구문으로 진행되지 않을 때, 즉 `break`, `continue`, `goto` 또는 `return`으로 인해서 구문 몸체가 종료될 경우, 불필요한 `else`는 생략되는 것을 발견할 수 있다.

```go
f, err := os.Open(name)
if err != nil{
    return err
}
codeUsing(f)
```



아래는 코드가 일련의 에러 조건들을 반드시 검사해야하는 일반적인 상황에 대한 예제이다. 만약 제어의 흐름이 성공적이라면 코드는 잘 동작할 것이고, 에러가 발생할 때마다 에러를 제거할 것이다. 에러 케이스들은 `return` 구문에서 종료하는 경향이 있기 때문에, 결과적으로 코드에 `else`구문이 필요하지 않다.

```go
f, err := os.Open(name)
if err != nil{
    return err
}

d, err := f.Stat()
if err != nil{
    f.Close()
    return err
}
codeUsing(f, d)
```

​    

### 재선언과 재할당

위의 예제에서 어떻게 `:=`짧은 선언문이 동작하는지 확인할 수 있었다. `os.Open`을 호출하는 선언 코드를 보자

```go
f, err := os.Open(name)
```

이 구문은 `f`와 `err`의 두개의 변수를 선언한다. 몇줄 아래 `f.Stat`을 호출하는 부분을 보자



```go
d, err := f.Stat()
```

여기서 `d`와 `err`를 선언하는 것 처럼 보인다. 주목할 부분은 `err`가 위에서, 그리고 아래 두 곳 모두에서 나타난다는 것이다. 



Go는 이렇게 사용하는 것을 허용하는데, `err`가 첫번째 구문을 통해서 선언되었지만 두번째에서는 재할당된다. 이는 `f.Stat`을 호출하는 것에서는 이미 선언되어 존재하는 `err`변수를 사용하고, 다시 새로운 값을 부여한다는 것을 의미한다.



변수의 단축선언 `v :=`에서 변수 `v`는 이미 선언되었더라도 다음의 경우 재선언이 가능하다.

- 해당 선언이 기존의 선언과 같은 스코프에 있어야한다.

  - 만약 `v`가 이미 외부 스코프에 선언되어있다면, 이 선언은 새 변수를 만들 것이다.

- 초기화 표현내에서 상응하는 값은 `v`에 할당할 수 있다.

  > ??

- 적어도 하나 이상의 새로운 변수가 선언문 안에 함께 있어야 한다.

  > ??



이 독특한 속성은 완전히 실용적이며*(???)*, 예를들어 길고 연쇄적인 `if-else` 구문에서 하나의 에러 값을 쉽게 사용할 수 있게 해준다. 자주 사용되는 것을 보게 될 것이다.



> Go 언어에서 함수 파라미터와 리턴 값들은, 함수를 감싸고 있는 브레이스들(braces) 밖에 위치해 있음에도, 그 스코프는 함수 몸통의 스코프와 동일하다는 점을 주목할 가치가 있다.



